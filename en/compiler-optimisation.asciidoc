[#compiler-optimisation]
= Compiler optimisations

This section covers some of the optimisations that the Go compiler performs.

For example; 

- Escape analysis
- Inlining
- Dead code elimination

are all handled in the front end of the compiler, while the code is still in its AST form; then the code is passed to the SSA compiler for further optimisation. 

== History of the Go compiler

The Go compiler started as a fork of the Plan9 compiler tool chain circa 2007. The compiler at that time bore a strong resemblance to Aho and Ullman's https://www.goodreads.com/book/show/112269.Principles_of_Compiler_Design[_Dragon Book_].

In 2015 the then Go 1.5 compiler was mechanically translated from https://golang.org/doc/go1.5#c[C into Go].

A year later, Go 1.7 introduced a https://blog.golang.org/go1.7[new compiler backend] based on https://en.wikipedia.org/wiki/Static_single_assignment_form[SSA] techniques replaced the previous Plan 9 style code generation.
This new backend introduced many opportunities for generic and architecture specific optimistions.

== Escape analysis

The first optimisation we're doing to discuss is _escape analysis_. 

To illustrate what escape analysis does recall that the https://golang.org/ref/spec[Go spec] does not mention the heap or the stack.
It only mentions that the language is garbage collected in the introduction, and gives no hints as to how this is to be achieved.

A compliant Go implementation of the Go spec _could_ store every allocation on the heap.
That would put a lot of pressure on the the garbage collector, but it is in no way incorrect -- for several years, gccgo had very limited support for escape analysis so could effectively be considered to be operating in this mode. 

However, a goroutine's stack exists as a cheap place to store local variables; there is no need to garbage collect things on the stack. Therefore, where it is safe to do so, an allocation placed on the stack will be more efficient.

In some languages, for example C and C++, the choice of allocating on the stack or on the heap is a manual exercise for the programmer--heap allocations are made with `malloc` and `free`, stack allocation is via `alloca`.
Mistakes using these mechanisms are a common cause of memory corruption bugs.

In Go, the compiler automatically moves a value to the heap if it lives beyond the lifetime of the function call. It is said that the value  _escapes_ to the heap.
[source,go,options=nowrap]
----
type Foo struct {
	a, b, c, d int
}

func NewFoo() *Foo {
	return &Foo{a: 3, b: 1, c: 4, d: 7}
}
----
In this example the `Foo` allocated in `NewFoo` will be moved to the heap so its contents remain valid after `NewFoo` has returned.

This has been present since the earliest days of Go.
It isn't so much an optimisation as an automatic correctness feature.
Accidentally returning the address of a stack allocated variable is not possible in Go.

But the compiler can also do the opposite; it can find things which would be assumed to be allocated on the heap, and move them to stack.

Let's have a look at an example
[source,go,options=nowrap]
----
include::../examples/esc/sum.go[tags=sum]
----

`Sum` adds the `int`s between 1 and 100 and returns the result.

Because the `numbers` slice is only referenced inside `Sum`, the compiler will arrange to store the 100 integers for that slice on the stack, rather than the heap. There is no need to garbage collect `numbers`, it is automatically freed when `Sum` returns.

=== Prove it!

To print the compilers escape analysis decisions, use the `-m` flag.

[source,options=nowrap]
% go build -gcflags=-m examples/esc/sum.go
# command-line-arguments
examples/esc/sum.go:22:13: inlining call to fmt.Println
examples/esc/sum.go:8:17: Sum make([]int, count) does not escape
examples/esc/sum.go:22:13: answer escapes to heap
examples/esc/sum.go:22:13: io.Writer(os.Stdout) escapes to heap
examples/esc/sum.go:22:13: main []interface {} literal does not escape
<autogenerated>:1: os.(*File).close .this does not escape

Line 8 shows the compiler has correctly deduced that the result of `make([]int, 100)` does not escape to the heap. The reason it did no

The reason line 22 reports that `answer` escapes to the heap is `fmt.Println` is a _variadic_ function.
The parameters to a variadic function are _boxed_ into a slice, in this case a `[]interface{}`, so `answer` is placed into a interface value because it is referenced by the call to `fmt.Println`.
Since Go 1.6 the garbage collector requires _all_ values passed via an interface to be pointers, what the compiler sees is _approximately_:

[source]
var answer = Sum()
fmt.Println([]interface{&answer}...)

We can confirm this using the `-gcflags="-m -m"` flag. Which returns

[source,options=nowrap]
% go build -gcflags='-m -m' examples/esc/sum.go 2>&1 | grep sum.go:22
examples/esc/sum.go:22:13: inlining call to fmt.Println func(...interface {}) (int, error) { return fmt.Fprintln(io.Writer(os.Stdout), fmt.a...) }
examples/esc/sum.go:22:13: answer escapes to heap
examples/esc/sum.go:22:13:      from ~arg0 (assign-pair) at examples/esc/sum.go:22:13
examples/esc/sum.go:22:13: io.Writer(os.Stdout) escapes to heap
examples/esc/sum.go:22:13:      from io.Writer(os.Stdout) (passed to call[argument escapes]) at examples/esc/sum.go:22:13
examples/esc/sum.go:22:13: main []interface {} literal does not escape

In short, don't worry about line 22, its not important to this discussion.

=== Exercises

- Does this optimisation hold true for all values of `count`?
- Does this optimisation hold true if `count` is a variable, not a constant?
- Does this optimisation hold true if `count` is a parameter to `Sum`?

=== Escape analysis (continued)

This example is a little contrived. It is not intended to be real code, just an example.

[source,go,options=nowrap]
----
include::../examples/esc/center.go[tags=point]
----

`NewPoint` creates a new `*Point` value, `p`. We pass `p` to the `Center` function which moves the point to a position in the center of the screen. Finally we print the values of `p.X` and `p.Y`.

[source,options=nowrap]
% go build -gcflags=-m examples/esc/center.go
# command-line-arguments
examples/esc/center.go:11:6: can inline Center
examples/esc/center.go:18:8: inlining call to Center
examples/esc/center.go:19:13: inlining call to fmt.Println
examples/esc/center.go:11:13: Center p does not escape
examples/esc/center.go:19:15: p.X escapes to heap
examples/esc/center.go:19:20: p.Y escapes to heap
examples/esc/center.go:19:13: io.Writer(os.Stdout) escapes to heap
examples/esc/center.go:17:10: NewPoint new(Point) does not escape
examples/esc/center.go:19:13: NewPoint []interface {} literal does not escape
<autogenerated>:1: os.(*File).close .this does not escape

Even though `p` was allocated with the `new` function, it will not be stored on the heap, because no reference `p` escapes the `Center` function.

_Question_: What about line 19, if `p` doesn't escape, what is escaping to the heap?

====
Write a benchmark to provide that `Sum` does not allocate.
====

== Inlining 

In Go function calls in have a fixed overhead; stack and preemption checks.

Some of this is ameliorated by hardware branch predictors, but it's still a cost in terms of function size and clock cycles.

Inlining is the classical optimisation that avoids these costs. 

Until Go 1.11 inlining only worked on _leaf functions_, a function that does not call another. The justification for this is:

- If your function does a lot of work, then the preamble overhead will be negligible. That's why functions over a certain size (currently some count of instructions, plus a few operations which prevent inlining all together (eg. switch before Go 1.7)
- Small functions on the other hand pay a fixed overhead for a relatively small amount of useful work performed. These are the functions that inlining targets as they benefit the most. 

The other reason is that heavy inlining makes stack traces harder to follow. 

=== Inlining (example)

[source,go,options="nowrap"]
----
include::../examples/inl/max.go[tags=max]
----
Again we use the `-gcflags=-m` flag to view the compilers optimisation decision.

[source]
% go build -gcflags=-m examples/inl/max.go
# command-line-arguments
examples/inl/max.go:4:6: can inline Max
examples/inl/max.go:11:6: can inline F
examples/inl/max.go:13:8: inlining call to Max
examples/inl/max.go:20:6: can inline main
examples/inl/max.go:21:3: inlining call to F
examples/inl/max.go:21:3: inlining call to Max

The compiler printed two lines. 

- The first at line 3, the declaration of `Max`, telling us that it can be inlined.
- The second is reporting that the body of `Max` has been inlined into the caller at line 12.

=== What does inlining look like?

Compile `max.go` and see what the optimised version of `F()` became.

[source,options=nowrap]
% go build -gcflags=-S examples/inl/max.go 2>&1 | grep -A5 '"".F STEXT'
"".F STEXT nosplit size=2 args=0x0 locals=0x0
        0x0000 00000 (/Users/dfc/devel/high-performance-go-workshop/examples/inl/max.go:11)     TEXT    "".F(SB), NOSPLIT|ABIInternal, $0-0
        0x0000 00000 (/Users/dfc/devel/high-performance-go-workshop/examples/inl/max.go:11)     FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (/Users/dfc/devel/high-performance-go-workshop/examples/inl/max.go:11)     FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (/Users/dfc/devel/high-performance-go-workshop/examples/inl/max.go:11)     FUNCDATA        $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
        0x0000 00000 (/Users/dfc/devel/high-performance-go-workshop/examples/inl/max.go:13)     PCDATA  $2, $0

This is the body of `F` once `Max` has been inlined into it -- there's nothing happening in this function.
I know there's a lot of text on the screen for nothing, but take my word for it, the only thing happening is the `RET`.
In effect `F` became:

[source,go]
func F() {
        return
}

[NOTE]
.What are FUNCDATA and PCDATA?
====
The output from `-S` is not the final machine code that goes into your binary.
The linker does some processing during the final link stage.
Lines like `FUNCDATA` and `PCDATA` are metadata for the garbage collector which are moved elsewhere when linking.
If you're reading the output of `-S`, just ignore `FUNCDATA` and `PCDATA` lines; they're not part of the final binary.

For the rest of the presentation I'll be using a small shell script to reduce the clutter in the assembly output.
[source,bash]
asm() {
        go build -gcflags=-S 2>&1 $@ | grep -v PCDATA | grep -v FUNCDATA | less
}
====


====
_Without_ using the `//go:noinline` comment, rewrite `Max` such that it still returns the right answer, but is no longer considered inlineable by the compiler.

Here's one way to do it
[source,go,options=nowrap]
----
include::../examples/inl/max_noinline.go
----

Let's see what the compiler thinks of it
[source,bash]
----
% go build -gcflags=-m max_noinline.go 
# command-line-arguments
./max_noinline.go:16:6: can inline F <1>
./max_noinline.go:25:6: can inline main
./max_noinline.go:26:3: inlining call to F
----
<1> The `can inline Max` line is now missing

We can double check this with two `-m` flags
[source,bash]
----
% go build -gcflags=-m=2 max_noinline.go 
# command-line-arguments
./max_noinline.go:6:6: cannot inline Max: unhandled op SELECT <1>
./max_noinline.go:16:6: can inline F as: func() { <node DCLCONST>; <node DCLCONST>; if Max(a, b) == b { panic(b) } } <2>
./max_noinline.go:25:6: can inline main as: func() { F() }
./max_noinline.go:26:3: inlining call to F func() { <node DCLCONST>; <node DCLCONST>; if Max(a, b) == b { panic(b) } }
----
<1> `Max` is no longer inlinable because it contains a `select` statement
<2> Note this is the code that the compiler sees, this is why `Max is inline twice`

====

=== Discussion

Why did I declare `a` and `b` in `F()` to be constants?

====
Experiment with the output of What happens if `a` and `b` are declared as  are variables?  What happens if `a` and `b` are passing into `F()` as parameters?
====

NOTE: `-gcflags=-S` doesn't prevent the final binary being build in your working directory. If you find that subsequent runs of `go build ...` produce no output, delete the `./max` binary in your working directory.

=== Adjusting the level of inlining

Adjusting the _inlining level_ is performed with the `-gcflags=-l` flag. Somewhat confusingly passing a single `-l` will disable inlining, and two or more will enable inlining at more aggressive settings.

- `-gcflags=-l`, inlining disabled.
- nothing, regular inlining.
- `-gcflags='-l -l'` inlining level 2, more aggressive, might be faster, may make bigger binaries.
- `-gcflags='-l -l -l'` inlining level 3, more aggressive again, binaries definitely bigger, maybe faster again, but might also be buggy.
- `-gcflags=-l=4` (four `-l`s) in Go 1.11 will enable the experimental https://github.com/golang/go/issues/19348#issuecomment-393654429[_mid stack_ inlining optimisation]. I believe as of Go 1.12 it has no effect.

=== Mid Stack inlining

Since Go 1.12 so called _mid stack_ inlining has been enabled (it was previously available in preview in Go 1.11 with the `-gcflags='-l -l -l -l'` flag).

We can see an example of mid stack inlining in the previous example. In Go 1.11 and earlier `F` would not have been a leaf function -- it called `max`.
However because of inlining improvements `F` is now inlined into its caller.
This is for two reasons;
. When `max` is inlined into `F`, `F` contains no other function calls thus it becomes a potential _leaf function_, assuming its complexity budget has not been exceeded.
. Because `F` is a simple function--inlining and dead code elimination has eliminated much of its complexity budget--it is eligable for _mid stack_ inlining irrispective of calling `max`.

[TIP]
====
Mid stack inlining can be used to inline the fast path of a function, eliminating the function call overhead in the fast path. 
https://go-review.googlesource.com/c/go/+/152698[This recent CL which landed in for Go 1.13] shows this technique applied to `sync.RWMutex.Unlock()`.
====

== Dead code elimination

Why is it important that `a` and `b` are constants?

To understand what happened lets look at what the compiler sees once its inlined `Max` into `F`. We can't get this from the compiler easily, but it's straight forward to do it by hand.

Before:
[source,go,options="nowrap"]
----
include::../examples/inl/max.go[tags=max]
----
After:
[source,go,options="nowrap"]
----
include::../examples/inl/max2.go[tags=max]
----
Because `a` and `b` are constants the compiler can prove at compile time that the branch will never be false; `100` is always greater than `20`.
So the compiler can further optimise `F` to 
[source,go,options="nowrap"]
----
include::../examples/inl/max3.go[tags=max]
----
Now that the result of the branch is know then then the contents of `result` are also known. This is call _branch elimination_.

[source,go,options="nowrap"]
func F() {
        const a, b = 100, 20
        const result = a
        if result == b {
                panic(b) 
        }
}

Now the branch is eliminated we know that `result` is always equal to `a`, and because `a` was a constant, we know that `result` is a constant. The compiler applies this proof to the second branch

[source,go,options="nowrap"]
func F() {
        const a, b = 100, 20
        const result = a
        if false {
                panic(b) 
        }
}

And using branch elimination again the final form of `F` is reduced to.

[source,go,options="nowrap"]
func F() {
        const a, b = 100, 20
        const result = a
}

And finally just

[source,go,options="nowrap"]

func F() {
}

=== Dead code elimination (cont.)

Branch elimination is one of a category of optimisations known as _dead code elimination_. In effect, using static proofs to show that a piece of code is never reachable, colloquially known as _dead_, therefore it need not be compiled, optimised, or emitted in the final binary.

We saw how dead code elimination works together with inlining to reduce the amount of code generated by removing loops and branches that are proven unreachable.

You can take advantage of this to implement expensive debugging, and hide it behind

[source,go,options="nowrap"]
const debug = false 

Combined with build tags this can be very useful.

=== Further reading

- http://dave.cheney.net/2014/09/28/using-build-to-switch-between-debug-and-release[Using // +build to switch between debug and release builds]
- http://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool[How to use conditional compilation with the go build tool]

== Prove pass

A few releases ago the SSA backend gained a, so called, prove pass.
Prove, the verb form of Proof, establishes the relationship between variables.

Let's look at an example to explain what prove is doing.
[source,go,options=nowrap]
----
include::../examples/prove/foo.go[]
----
<1> At this point the compiler knows that x is greater than 5
<2> Therefore x is _also_ greater than 3, this the branch is always taken.

=== Prove it (ha!)

Just as with inining and escape analysis we can ask the compiler to show us the working of the prove pass.
We do this with the `-d` flag passed to `go tool compile` via `-gcflags`

[source,bash]
% go build -gcflags=-d=ssa/prove/debug=on foo.go 
# command-line-arguments
./foo.go:5:10: Proved Greater64

Line 5 is `if x > 3`.
The compiler is saying that is has proven that the branch will always be true.

====
Experiment with the output of What happens if `a` and `b` are declared as  are variables?  What happens if `a` and `b` are passing into `F()` as parameters?
====

== Compiler intrinsics

Go allows you to write functions in assembly if required.
The technique involves a forwarding declared function--a function without a body--and a corresponding assembly function.

[source,go,options=nowrap]
.decl.go
----
include::../examples/asm/decl.go[]
----
Here we're declaring an `Add` function which takes two `int64`'s and returns a third.
Note the `Add` function has no body.
If we were to compile it we would see something like this
[source,bash,options=nowrap]
% go build
# high-performance-go-workshop/examples/asm [high-performance-go-workshop/examples/asm.test]
./decl.go:4:6: missing function body

To satisfy the compiler we must supply the assembly for this function, which we can do via a `.s` file in the same package.

[source]
.add.s
----
include::../examples/asm/add.s[]
----

Now we can build, test, and use our `asm.Add` function just like normal Go code.

But there's a problem, assembly functions *cannot be inlined*.
This has long been a complaint by Go developers who need to use assembly either for performance, or for operations which are not exposed in the language; vector instructions, atomic primatives and so on, which when written as assembly functions pay a high overhead cost because they cannot be inlined.

There have been various proposals for an inline assembly syntax for Go, similar to GCC's `asm(...)` directive, but they have not been accepted by the Go developers.
Instead, Go has added _intrinsic functions_.

An intrinsic function is regular Go code written in regular Go, however the compiler contains specific drop in replacements for the functions.

The two packages that make use of this this are

- `math/bits`
- `sync/atomic`

These replacements are implemented in the compiler backend; if your architecture supports a faster way of doing an operation it will be transparently replaced with the comparable instruction during compilation.

As well as generating more efficient code, because intrinsic functions are just normal Go code, the rules of 
inlining, and mid stack inlining apply to them.

=== Atomic counter example

[source,go,options=nowrap]
----
include::../examples/counter/counter.go[]
----
This means examples like the one above compile to efficient native code on most platforms.
[source,asm,options=nowrap]
----
"".f STEXT nosplit size=36 args=0x8 locals=0x0
        0x0000 00000 (/tmp/counter.go:21)       TEXT    "".f(SB), NOSPLIT|ABIInternal, $0-8
        0x0000 00000 (<unknown line number>)    NOP
        0x0000 00000 (/tmp/counter.go:22)       MOVL    $1, AX
        0x0005 00005 (/tmp/counter.go:13)       LEAQ    "".c(SB), CX
        0x000c 00012 (/tmp/counter.go:13)       LOCK
        0x000d 00013 (/tmp/counter.go:13)       XADDQ   AX, (CX) <1>
        0x0011 00017 (/tmp/counter.go:23)       XCHGL   AX, AX
        0x0012 00018 (/tmp/counter.go:10)       MOVQ    "".c(SB), AX <2>
        0x0019 00025 (<unknown line number>)    NOP
        0x0019 00025 (/tmp/counter.go:16)       XORL    AX, AX
        0x001b 00027 (/tmp/counter.go:16)       XCHGQ   AX, (CX) <3>
        0x001e 00030 (/tmp/counter.go:24)       MOVQ    AX, "".~r0+8(SP)
        0x0023 00035 (/tmp/counter.go:24)       RET
        0x0000 b8 01 00 00 00 48 8d 0d 00 00 00 00 f0 48 0f c1  .....H.......H..
        0x0010 01 90 48 8b 05 00 00 00 00 31 c0 48 87 01 48 89  ..H......1.H..H.
        0x0020 44 24 08 c3                                      D$..
        rel 8+4 t=15 "".c+0
        rel 21+4 t=15 "".c+0
----
<1> `c.inc()`
<2> `c.get()`
<3> `c.reset()`

==== Further reading

- https://docs.google.com/presentation/d/1Wcblp3jpfeKwA0Y4FOmj63PW52M_qmNqlQkNaLj0P5o/edit#slide=id.p[Mid-stack inlining in the Go compiler presentation by David Lazar]
- https://github.com/golang/proposal/blob/master/design/19348-midstack-inlining.md[Proposal: Mid-stack inlining in the Go compiler]

#TODO: double check#

////
== Bounds check elimination

Go is a bounds checked language.
This means array and slice subscript operations are checked to ensure they are within the bounds of the respective types.

For arrays, this can be done at compile time.
For slices, this must be done at run time.

[source,go,options=nowrap]
----
include::../examples/bounds/bounds_test.go[tags=inorder]
----

====
Use `-gcflags=-S` to disassemble `BenchmarkBoundsCheckInOrder`. How many bounds check operations are performed per loop?
====

[source,go,options=nowrap]
----
include::../examples/bounds/bounds_test.go[tags=outoforder]
----

====
Does rearranging the order in which we assign the `A` through `I` affect the assembly. Disassemble `BenchmarkBoundsCheckOutOfOrder` and find out.
====

=== Exercises

- Does rearranging the order of subscript operations affect the size of the function? Does it affect the speed of the function?
- What happens if `v` is moved inside the `Benchmark` function?
- What happens if `v` was declared as an array, `var v [9]int`?
////

== Compiler flags Exercises

Compiler flags are provided with:

[source,options="nowrap"]
go build -gcflags=$FLAGS

Investigate the operation of the following compiler functions:

- `-S` prints the (Go flavoured) assembly of the _package_ being compiled.
- `-l` controls the behaviour of the inliner; `-l` disables inlining, `-l -l` increases it (more `-l` 's increases the compiler's appetite for inlining code). Experiment with the difference in compile time, program size, and run time.
- `-m` controls printing of optimisation decision like inlining, escape analysis. `-m`-m` prints more details about what the compiler was thinking.
- `-l -N` disables all optimisations.
- `-d=ssa/prove/debug=on`, this also takes values of 2 and above, see what prints
- The `-d` flag takes other values, you can find out what they are with the command `go tool compile -d help`. Experiment and see what you can discovrer.

NOTE: If you find that subsequent runs of `go build ...` produce no output, delete the output binary in your working directory.

=== Further reading

- http://go-talks.appspot.com/github.com/rakyll/talks/gcinspect/talk.slide#1[Codegen Inspection by Jaana Burcu Dogan]


////
=== Nil check elimination

https://go-review.googlesource.com/c/go/+/151177

=== Range check elimination?

=== Write barrier elision

=== Map elision

=== Shift ordering elision
////